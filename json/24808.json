{
   "data" : {
      "userid" : {
         "name" : "David Muir Sharnoff",
         "id" : "MUIR"
      },
      "description" : "Tied Filehandles for Nonblocking IO w/callbk",
      "psuedo-parameter" : "\"Description\".",
      "communities" : "",
      "chapterid" : {
         "name" : "File_Handle_Input_Output",
         "id" : "21"
      },
      "similar" : "",
      "DSLIP" : "adphp",
      "modid" : "IO::Event",
      "enteredon" : "Sun Nov 30 08:24:57 2003 GMT",
      "enteredby" : {
         "name" : "David Muir Sharnoff",
         "id" : "MUIR"
      },
      "PS" : "The following links are only valid for module list maintainers:",
      "rationale" : "I've sent this in before. I heard nothing. I've been working on\n    this module recently and I may have it debugged to the point of\n    actually being useful :-)\n\n    I'm not happy that my prior submission was completely ignored.\n\n    NAME IO::Event - Tied Filehandles for Nonblocking IO with Object\n    Callbacks\n\n    DESCRIPTION IO::Event provides a object-based callback system for\n    handling nonblocking IO. The design goal is to provide a system that\n    just does the right thing w/o the user needing to think about it\n    much.\n\n    All APIs are kept as simple as possible yet at the same time, all\n    functionality is accesible if needed. Simple things are easy. Hard\n    things are possible.\n\n    Most of the time file handling syntax will work fine:\n    \"<$filehandle>\" and \"print $filehandle 'stuff'\".\n\n    CONSTRUCTORS IO::Event->new($filehandle, $handler) The basic \"new\"\n    constructor takes a filehandle and returns a psuedo-filehandle.\n    Treat the IO::Event object as a filehandle. Do not use the original\n    filehandle without good reason (let us know if you find a good\n    reason so we can fix the problem).\n\n    The handler is the class or object where you provide callback\n    functions to handle IO events. It defaults to the package of the\n    calling context.\n\n    IO::Event::Socket::INET->new( [ARGS] ) This constructor uses\n    IO::Socket::INET->new() to create a socket using the ARGS provided.\n    It returns an IO::Event object.\n\n    The handler defaults as above or can be set with an additional\n    pseudo-parameter for IO::Socket::UNIX->new(): \"Handler\". A\n    description for the socket can be provided with an additional\n    psuedo-parameter: \"Description\".\n\n    IO::Event::Socket::UNIX->new( [ARGS] ) This constructor uses\n    IO::Socket::UNIX->new() to create a socket using the ARGS provided.\n    It returns an IO::Event object.\n\n    The handler defaults as above or can be set with an additional\n    pseudo-parameter for IO::Socket::UNIX->new(): \"Handler\". A\n    description for the socket can be provided with an additional\n    psuedo-parameter: \"Description\".\n\n    MANDATORY HANDLERS These handler methods must be available in the\n    handler object/class if the situation in which they would be called\n    arises.\n\n    ie_input($handler, $ieo, $input_buffer_reference) Invoked when\n    there is fresh data in the input buffer. The input can be retreived\n    via directly reading it from $$input_buffer_reference or via\n    \"read()\" from the $ieo filehandle, or by using a variety of standard\n    methods for getting data:\n\n    <$ieo> like IO::Handle $ieo->get() like Data::LineBuffer\n    $ieo->read() like IO::Handle $ieo->sysread() like IO::Handle\n    $ieo->getline() like IO::Handle $ieo->getlines() like IO::Handle\n    $ieo->getsome() see below\n\n    At end-of-file, ie_input will only be invoked once. There may or\n    may not be data in the input buffer.\n\n    ie_connection($handler, $ieo) Invoked when a listen()ing socket is\n    ready to accept(). It should call accept:\n\n    sub ie_connection { my ($ieo) = @_; my $newfh = $ieo->accept() }\n\n    ie_read_ready($handler, $underlying_file_handle) If autoreading is\n    turned off then this will be invoked.\n\n    charm:IO-Event<673> charm:IO-Event<673> charm:IO-Event<673> cat\n    README NAME IO::Event - Tied Filehandles for Nonblocking IO with\n    Object Callbacks\n\n    DESCRIPTION IO::Event provides a object-based callback system for\n    handling nonblocking IO. The design goal is to provide a system that\n    just does the right thing w/o the user needing to think about it\n    much.\n\n    All APIs are kept as simple as possible yet at the same time, all\n    functionality is accesible if needed. Simple things are easy. Hard\n    things are possible.\n\n    Most of the time file handling syntax will work fine:\n    \"<$filehandle>\" and \"print $filehandle 'stuff'\".\n\n    CONSTRUCTORS IO::Event->new($filehandle, $handler) The basic \"new\"\n    constructor takes a filehandle and returns a psuedo-filehandle.\n    Treat the IO::Event object as a filehandle. Do not use the original\n    filehandle without good reason (let us know if you find a good\n    reason so we can fix the problem).\n\n    The handler is the class or object where you provide callback\n    functions to handle IO events. It defaults to the package of the\n    calling context.\n\n    IO::Event::Socket::INET->new( [ARGS] ) This constructor uses\n    IO::Socket::INET->new() to create a socket using the ARGS provided.\n    It returns an IO::Event object.\n\n    The handler defaults as above or can be set with an additional\n    pseudo-parameter for IO::Socket::UNIX->new(): \"Handler\". A\n    description for the socket can be provided with an additional\n    psuedo-parameter: \"Description\".\n\n    IO::Event::Socket::UNIX->new( [ARGS] ) This constructor uses\n    IO::Socket::UNIX->new() to create a socket using the ARGS provided.\n    It returns an IO::Event object.\n\n    The handler defaults as above or can be set with an additional\n    pseudo-parameter for IO::Socket::UNIX->new(): \"Handler\". A\n    description for the socket can be provided with an additional\n    psuedo-parameter: \"Description\".\n\n    MANDATORY HANDLERS These handler methods must be available in the\n    handler object/class if the situation in which they would be called\n    arises.\n\n    ie_input($handler, $ieo, $input_buffer_reference) Invoked when\n    there is fresh data in the input buffer. The input can be retreived\n    via directly reading it from $$input_buffer_reference or via\n    \"read()\" from the $ieo filehandle, or by using a variety of standard\n    methods for getting data:\n\n    <$ieo> like IO::Handle $ieo->get() like Data::LineBuffer\n    $ieo->read() like IO::Handle $ieo->sysread() like IO::Handle\n    $ieo->getline() like IO::Handle $ieo->getlines() like IO::Handle\n    $ieo->getsome() see below\n\n    At end-of-file, ie_input will only be invoked once. There may or\n    may not be data in the input buffer.\n\n    ie_connection($handler, $ieo) Invoked when a listen()ing socket is\n    ready to accept(). It should call accept:\n\n    sub ie_connection { my ($ieo) = @_; my $newfh = $ieo->accept() }\n\n    ie_read_ready($handler, $underlying_file_handle) If autoreading is\n    turned off then this will be invoked.\n\n    ie_werror($handler, $output_buffer_reference) A write error has\n    occured when trying to drain the write buffer. Provide an empty\n    subroutine if you don't care.\n\n    OPTIONAL HANDLERS These handler methods will be called if they are\n    defined but it is not required that they be defined.\n\n    ie_eof($handler, $ieo, $input_buffer_reference) This is invoked\n    when the read-side of the filehandle has been closed by its source.\n\n    ie_output This is invoked when data has just been written to the\n    underlying filehandle.\n\n    ie_outputdone This is invoked when all pending data has just been\n    written to the underlying filehandle.\n\n    ie_connected This is invoked when a \"connect()\" completes.\n\n    ie_connect_timeout This is invoked when a \"connect()\" attempt times\n    out.\n\n    ie_died($handler, $ieo, $method, $@) If another handler calls \"die\"\n    then ie_died will be called with the IO::Event object, the name of\n    the method just invoked, and the die string.\n\n    ie_timer This is invoked for timer events. These will only arise if\n    set using thing underlying Event object.\n\n    ie_exception Invoked when an exceptional condition arises on the\n    underlying filehandle\n\n    ie_outputoverflow($handler, $ieo, $overflowing,\n    $output_buffer_reference) Invoked when there is too much output data\n    and the output buffers are overflowing. You can take some action to\n    generate less output. This will be invoked exactly once (with\n    $overflowing == 1) when there is too much data in the buffer and\n    then exactly once again (with $overflowing == 0) when there is no\n    longer too much data in the buffer.\n\n    METHODS In addition to methods described in detail below, the\n    following methods behave like their \"IO\" (mostly \"IO::Socket\")\n    counterparts (except for being mostly non-blocking...):\n\n    connect listen open close read sysread syswrite print eof\n\n    Through AUTOLOAD (see the SUBSTITUTED METHODS section) methods are\n    passed to underlying \"Event\" objects:\n\n    loop unloop and many more...\n\n    Through AUTOLOAD (see the SUBSTITUTED METHODS section) methods are\n    passed to underlying \"IO\" objects:\n\n    fileno stat truncate error opened untaint and many more...\n\n    IO::Event defines its own methods too:\n\n    ->accept($handler) accept() is nearly identical to the normal\n    IO::Socket::accept() method except that instead of optionally\n    passing a class specifier for the new socket, you optionally pass a\n    handler object/class. The returned filehandle is an IO::Event\n    object.\n\n    ->getsome($amount) Returns $amount bytes worth of input or undef if\n    the request can't be filled. Returns what it can at EOF.\n\n    ->get() get() is like getline() except that it pre-chomp()s the\n    results and assumes the input_record_separator is \"\\n\". This is like\n    get() from Data::LineBuffer.\n\n    ->unget() Push chomp()ed lines back into the input buffer. This is\n    like unget() from Data::LineBuffer.\n\n    ->ungetline() Push un-chomp()ed lines back into the input buffer.\n\n    ->xungetc() This is what ungetc() should be: it pushes a string\n    back into the input buffer. This is unlike IO::Handle->ungetc which\n    takes an ordinal and pushes one character back into the the input\n    buffer.\n\n    ->handler($new_handler) Sets the handler object/class if\n    $new_handler is provided. Returns the old handler.\n\n    ->filehandle() Returns the underlying \"IO::Handle\".\n\n    ->event() Returns the underling \"Event\".\n\n    ->listener($listening) Used to note that a filehandle is being used\n    to listen for connections (instead of receiving data). A passed\n    parameter of 0 does the opposite. Returns the old value. This is\n    mostly used internally in IO::Event.\n\n    ->input_record_separator($new_sep) IO::Handle doesn't allow\n    input_record_separator's on a per filehandle basis. IO::Event does.\n    If you don't ever set a filehandle's input record separator, then it\n    contineously defaults to the current value of $/. If you set it,\n    then it will use your value and never look at $/ again.\n\n    ->readevents($readevents) Get/set listening for read-ready events\n    on the underlying filehandle. This could be used by\n    ie_outputoverflow to control input flows.\n\n    ->output_bufsize($output_bufsize) Get/set the size of the output\n    buffer.\n\n    ->autoread($autoread) Get/set automatic reading if data when data\n    can be read. Without autoread turned on, the input buffer ins't\n    filled and none of the read methods will work. The point of this is\n    for working with non-data filehandles. This is an experts-only\n    method that kinda defeats the purpose of this module. This would be\n    necessary using recv() to get data.\n\n    ->drain() Used to start looking for write-ready events on the\n    underlying filehandle. In normal operation this is handled\n    automatically.\n\n    ->reentrant($reentrant) Get/set reentrant callbacks. By default,\n    IO::Event avoids making reentrant callbacks. This is good because\n    your code is less likely to break. This is bad because you won't\n    learn about things right away. For example, you will not learn the\n    the output buffer is overflowing during print(). You'll have to wait\n    for the output buffer to begin draining to find out. This could be a\n    problem.\n\n    SUBSTITUED METHODS Any method invocations that fail because the\n    method isn't defined in IO::Event will by tried twice more: once\n    using trying for a method on the inner (hidden) filehandle and once\n    more trying for a method on the Event object that's used to create\n    the select loop for this module.\n\n    EXAMPLE SERVER # This is a tcp line echo server\n\n    my $listener = IO::Event::Socket::INET->new( Listen => 10, Proto =>\n    'tcp', LocalPort => 2821, );\n\n    Event::loop();\n\n    sub ie_connection { my ($pkg, $lstnr) = @_; my $client =\n    $lstnr->accept(); printf \"accepted connection from %s:%s\\n\",\n    $client->peerhost, $client->peerport; }\n\n    sub ie_input { my ($pkg, $client, $ibufref) = @_; print $client\n    <$client>; }\n\n    SYSREAD and EOF sysread() is incompatable with eof() because eof()\n    uses getc(). Most of the time this isn't a problem. In other words,\n    some of the time this is a problem: lines go missing.\n\n    For this reason, IO::Event never uses sysread(). In fact, if you\n    ask it to do a sysread() it does a read() for you instead.\n\n    On the other hand, at the current time no problems with syswrite\n    have come to light and IO::Event uses syswrite and never any other\n    form of write/print etc.\n\n    DATA STRUCTURE The filehandle object itself is a funny kind of hash\n    reference. If you want to use it to store your own data, you can.\n    Please don't use hash keys that begin \"ie_\" or \"io_\" as those are\n    the prefixes used by \"IO::Event\" and \"IO::Socket\".\n\n    The syntax is kinda funny:\n\n    ${*$filehandle}{'your_hash_key'}\n\n    SEE ALSO The following perl modules do something that is kinda\n    similar to what is being done here:\n\n    IO::Multiplex IO::NonBlocking IO::Select Event POE\n    POE::Component::Server::TCP Net::Socket::NonBlock\n    Net::Server::Multiplex NetServer::Generic\n\n    The API borrows most heavily from IO::Multiplex. IO::Event uses\n    Event.pm and thus can be used in programs that are already using\n    Event or POE.\n\n    BUGS This code is still greenish. The test suite only covers 40% of\n    the code.\n\n    Nothing sane is done with excptional conditions. What causes them\n    anyway?\n\n    LICENSE Copyright (C) 2002-2003 David Muir Sharnoff\n    <muir@idiom.com>. This module may be used/copied/etc on the same\n    terms as Perl itself."
   },
   "meta" : {
      "message_id" : "200311300824.hAU8OwP5008865@pause.perl.org",
      "epoch" : 1070180698,
      "from" : "upload@pause.perl.org",
      "subject" : "Module submission IO::Event",
      "file" : "24808.txt",
      "type" : "module_submission"
   }
}
