{
   "data" : {
      "userid" : {
         "name" : "Darren Duncan",
         "id" : "DUNCAND"
      },
      "description" : "Refer to user messages in programs by keys",
      "communities" : "modules@perl.org",
      "chapterid" : {
         "name" : "Internationalization_Locale",
         "id" : "13"
      },
      "similar" : "Locale::gettext, Locale::PGetText, others",
      "DSLIP" : "cdpOp",
      "modid" : "Locale::KeyedText",
      "enteredon" : "Mon Jun  2 21:03:07 2003 GMT",
      "enteredby" : {
         "name" : "Darren Duncan",
         "id" : "DUNCAND"
      },
      "PS" : "The following links are only valid for module list maintainers:",
      "rationale" : "Many times during a program's operation, the program (or a module\n    it uses) will need to display a message to the user, or generate a\n    message to be shown to the user. Often this is an error message of\n    some kind, but it could also be a prompt message for interactive\n    systems.\n\n    Modern programs or database systems often refer to an error\n    condition by an internal code which is guaranteed to be unique for a\n    situation, and this is mapped to a user-readable message at some\n    point. For example, Oracle databases often have error codes in a\n    format like 'ORA-03542'. Any application receiving such a code can\n    identify it easily in its conditional logic, using a simple\n    'equals', and then the application can \"do the right thing\". No\n    parsing or ambiguity involved. By contrast, if a program simply\n    returned words for the user, such as 'error opening file', programs\n    would have a harder time figuring out the best way to deal with it.\n    But for displaying to users, easy messages are better. Also,\n    different users have their own languages, and users with either\n    different skill levels or different security privileges, should be\n    shown different messages for the same error conditions. Developers\n    get more details, joe public gets very little.\n\n    I have found that when it comes to getting the most accurate, the\n    most accurate program text for users, we still get the best results\n    by having a human being write out that text themselves.\n\n    What my module does is associate a set of key-codes, which are\n    hard-coded into your application or module, each with one or more\n    text strings to show human users. This association would normally be\n    stored in a Perl file that defines and returns an anonymous hash\n    definition. While it is obvious that people who would be writing the\n    text would have to know how to edit Perl files, this shouldn't be a\n    problem because my module is only meant to be used with user text\n    that is associated with hard-coded program conditions. In other\n    words, this user text is *part of the program*, and not the\n    program's users' own data. At the same time, this information is in\n    separate resource files used by the program, so that if you wanted\n    to upgrade or localize what text the user sees, you only have to\n    update said separate resource files, and not change your main\n    program.\n\n    I was inspired to have this organization partly by how Mac OS X\n    manages its resources. It is the standard practice for Mac OS X\n    programs, including the operating system itself, to have the user\n    language data in separate files (usually XML files I think) from the\n    main program binary. Each user language is in a separate file, and\n    adding a localization to a Mac OS X program is as simple as adding a\n    language file to the program package. No recompilation necessary.\n    This is something that end users could do, although program package\n    installers usually do it. An os-level preference / control-panel\n    displays a list of all the languages your programs do or might have,\n    and lets you arrange the list in order of preference. When you open\n    a program, it will search for language files specific to the program\n    in the order you chose so to pick a supported language closest to\n    your preference. Presumably the messages in these files are looked\n    up by the program using keys. Mac OS X (and the previous non-Unix\n    Mac OS) handles lots of other program resources as data files as\n    well, making them easy to upgrade.\n\n    My module aims to bring this sort of functionality to Perl modules\n    or programs. Your module or program can be distributed with one or\n    more resource files containing text for users, and your program\n    would use associated keys internally.\n\n    It is strongly suggested (but not required) that each Perl module\n    which uses this would come up with keys which are unique across all\n    Perl modules (perhaps the key name can start with the module name?).\n    An advantage of this is that, for example, your module could come\n    with a set of user messages, but another module or program which\n    uses yours may wish to override some of your messages, showing other\n    messages instead which are more appropriate to the context in which\n    they are using your module. One can override simply by using the\n    same key code with a new user message in one of their own resource\n    files. At some appropriate place, usually in the main program, my\n    module can be given input that says what resource files it should\n    use and in what order they should be consulted. When my module is\n    told to fetch the user message for a certain code, it returns the\n    first one it finds. This also works for the multiple language or\n    permissions issue; simply order the files appropriately in the\n    search list. The analogy is similar to inheriting from multiple\n    modules which have the same method names as you or each other, or\n    having multiple search directories in your path that modules could\n    be installed in.\n\n    Generally, when a program module would return a code-key to\n    indicate a condition, often it will also provide some variable\n    values to be interpolated into the user strings; my module would\n    also handle this.\n\n    My module never outputs anything by itself to the user, and only\n    implements deterministic functionality, returning its results.\n\n    One of the main distinctions of my approach over similar modules is\n    that text is always looked up by a key which is not meant to be\n    meaningful for a user. Whereas, with the other modules it looks like\n    you are supposed to pass in english text and they translate it,\n    which could produce ambiguous results or associations. Or\n    alternately, the other modules require your text data to be stored\n    in a format other than Perl files. Or alternately they have a\n    compiled C component or otherwise have external dependencies; my\n    module has no external dependencies (it is very simple). There are\n    other differences.\n\n    I know that Tim Bunce recently suggested that this new module idea\n    of mine could be quite popular, implying something like it didn't\n    exist yet. Or perhaps he was just talking about my distributing a\n    predefined set of error messages that could be used with any\n    database-using module. I'm not sure.\n\n    In any event, I welcome any feedback as to whether what I describe\n    seems to be already implemented, or not. Or alternately, whether you\n    have trouble understanding what I am proposing. But this is meant to\n    be a simple module in any event, and a small module."
   },
   "meta" : {
      "message_id" : "200306022103.h52L38YP011532@pause.perl.org",
      "epoch" : 1054587788,
      "from" : "upload@pause.x.perl.org",
      "subject" : "Module submission Locale::KeyedText",
      "file" : "21441.txt",
      "type" : "module_submission"
   }
}
