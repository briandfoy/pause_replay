{
   "data" : {
      "userid" : {
         "name" : "Brian McCauley",
         "id" : "NOBULL"
      },
      "description" : "Apply Perl's qq interpolation to strings",
      "communities" : "comp.lang.perl.modules",
      "chapterid" : {
         "name" : "String_Lang_Text_Proc",
         "id" : "11"
      },
      "similar" : "",
      "DSLIP" : "adphp",
      "modid" : "String::Interpolate",
      "enteredon" : "Wed Apr 17 11:14:45 2002 GMT",
      "enteredby" : {
         "name" : "Brian McCauley",
         "id" : "NOBULL"
      },
      "PS" : "The following links are only valid for module list maintainers:",
      "rationale" : "I think the choice of String::Interpolate is self-explanatory.\n\n    I believe there is a widespread desire for a neat solution to\n    applying Perl's inbuilt interpolation engine to values in scalars.\n    (The question is asked about once a week in comp.lang.perl.*).\n\n    At it's simplest:\n\n    use String::Interpolate qw(interpolate); my $string =\n    interpolate($template);\n\n    Is the same as:\n\n    chop ( my $string = eval \"<<EOF\\n$template\\nEOF\\n\" ); die $@ if $@;\n\n    The module also provides a lot more too.\n\n    I note there is a nanny-state school of thought that believes that\n    the above trick is too evil to tell the masses. At least by putting\n    it in a module the module documentation can clearly explain the\n    hazards."
   },
   "meta" : {
      "message_id" : "200204171114.NAA13789@pause.perl.org",
      "epoch" : 1019042085,
      "from" : "upload@p11.speed-link.de",
      "subject" : "Module submission String::Interpolate",
      "file" : "11245.txt",
      "type" : "module_submission"
   }
}
