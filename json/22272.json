{
   "data" : {
      "userid" : {
         "name" : "Darren Duncan",
         "id" : "DUNCAND"
      },
      "Note" : "This standalone module was uploaded to CPAN today as part of",
      "description" : "Unserialized SQL objects, use like XML DOM",
      "communities" : "modules@perl.org, poop-group@lists.sourceforge.net,\n    dbi-users@perl.org, victoria-pm@pm.org",
      "chapterid" : {
         "name" : "String_Lang_Text_Proc",
         "id" : "11"
      },
      "similar" : "SQL::Statement, SQL::Translator, SQL::YASP, DBIx::Abstract, others",
      "DSLIP" : "adhOg",
      "modid" : "SQL::ObjectModel",
      "enteredon" : "Tue Jul  8 04:36:56 2003 GMT",
      "enteredby" : {
         "name" : "Darren Duncan",
         "id" : "DUNCAND"
      },
      "PS" : "The following links are only valid for module list maintainers:",
      "rationale" : "Note: This standalone module was uploaded to CPAN today as part of\n    my Rosetta-0.15 distribution. Unlike the other files in Rosetta,\n    SQL::ObjectModel is code-complete and POD-complete and can be used\n    right now (hence the alpha and not pre-alpha dev status). I would\n    very much like SQL::ObjectModel to spin off into its own\n    distribution, so it is easier for people to download that without\n    having to download the other Rosetta framework files (and a\n    separation of the docs is just plain logical). But until this module\n    is registered I don't want to put it in its own distribution, in\n    case I have to rename it for some reason.\n\n    If search.cpan.org hasn't updated to show the new version by the\n    time you read this, you can see it on my own server at\n    \"http://darrenduncan.net/d/perl/Rosetta-0.15.tar.gz\" or\n    \"http://darrenduncan.net/d/perl/Rosetta-0.15/lib/SQL/ObjectModel.pm\"\n    (temp urls).\n\n    Following is the \"final\"/mature DESCRIPTION from my module's POD,\n    which should explain what it does and how it compares to other\n    similar modules. If you go to the module itself, you can see the\n    SYNOPSIS having code examples of use, and other useful documentation\n    like the API.\n\n    Thank you in advance for your prompt consideration.\n\n    ---------------- DESCRIPTION\n\n    This Perl 5 object class is intended to be a powerful but easy to\n    use replacement for SQL strings (including support for\n    placeholders), which you can use to make queries against a database.\n    Each SQL::ObjectModel object can represent a non-ambiguous\n    structured command for a database to execute, or one can be a\n    non-ambiguous structured description of a database schema object.\n    This class supports all types of database operations, including both\n    data manipulation and schema manipulation, as well as managing\n    database instances and users. You typically construct a database\n    query by setting appropriate attributes of these objects, and you\n    execute a database query by evaluating the same attributes.\n    SQL::ObjectModel objects are designed to be equivalent to SQL in\n    both the type of information they carry and in their conceptual\n    structure. This is analagous to how XML DOMs are objects that are\n    equivalent to XML strings, and they can be converted back and forth\n    at will. If you know SQL, or even just relational database theory in\n    general, then this module should be easy to learn.\n\n    SQL::ObjectModels are intended to represent all kinds of SQL, both\n    DML and DDL, both ANSI standard and RDBMS vendor extensions. Unlike\n    basically all of the other SQL generating/parsing modules I know\n    about, which are limited to basic DML and only support table\n    definition DDL, this class supports arbitrarily complex select\n    statements, with composite keys and unions, and calls to stored\n    functions; this class can also define views and stored procedures\n    and triggers. Some of the existing modules, even though they\n    construct complete SQL, will take/require fragments of SQL as input\n    (such as \"where\" clauses) By contrast, SQL::ObjectModel takes no SQL\n    fragments. All of its inputs are atomic, which means it is also\n    easier to analyse the objects for implementing a wider range of\n    functionality than previously expected; for example, it is much\n    easier to analyse any select statement and generate\n    update/insert/delete statements for the virtual rows fetched with it\n    (a process known as updateable views).\n\n    Considering that each database product has its own dialect of SQL\n    which it implements, you would have to code SQL differently\n    depending on which database you are using. One common difference is\n    the syntax for specifying an outer join in a select query. Another\n    common difference is how to specify that a table column is an\n    integer or a boolean or a character string. Moreover, each database\n    has a distinct feature set, so you may be able to do tasks with one\n    database that you can't do with another. In fact, some databases\n    don't support SQL at all, but have similar features that are\n    accessible thorough alternate interfaces. SQL::ObjectModel is\n    designed to represent a normalized superset of all database features\n    that one may reasonably want to use. \"Superset\" means that if even\n    one database supports a feature, you will be able to invoke it with\n    this class. You can also reference some features which no database\n    currently implements, but it would be reasonable for one to do so\n    later. \"Normalized\" means that if multiple databases support the\n    same feature but have different syntax for referencing it, there\n    will be exactly one way of referring to it with SQL::ObjectModel. So\n    by using this class, you will never have to change your\n    database-using code when moving between databases, as long as both\n    of them support the features you are using (or they are emulated).\n    That said, it is generally expected that if a database is missing a\n    specific feature that is easy to emulate, then code which evaluates\n    SQL::ObjectModels will emulate it (for example, emulating \"left()\"\n    with \"substr()\"); in such cases, it is expected that when you use\n    such features they will work with any database. For example, if you\n    want a model-specified boolean data type, you will always get it,\n    whether it is implemented on a per-database-basis as a \"boolean\" or\n    an \"int(1)\" or a \"number(1,0)\". Or a model-specified \"str\" data type\n    you will always get it, whether it is called \"text\" or \"varchar2\" or\n    \"sql_varchar\".\n\n    SQL::ObjectModel is intended to be just a stateless container for\n    database query or schema information. It does not talk to any\n    databases by itself and it does not generate or parse any SQL;\n    rather, it is intended that other third party modules or code of\n    your choice will handle this task. In fact, SQL::ObjectModel is\n    designed so that many existing database related modules could be\n    updated to use it internally for storing state information,\n    including SQL generating or translating modules, and schema\n    management modules, and modules which implement object persistence\n    in a database. Conceptually speaking, the DBI module itself could be\n    updated to take SQL::ObjectModel objects as arguments to its\n    \"prepare\" method, as an alternative (optional) to the SQL strings it\n    currently takes. Code which implements the things that\n    SQL::ObjectModel describes can do this in any way that they want,\n    which can mean either generating and executing SQL, or generating\n    Perl code that does the same task and evaling it, should they want\n    to (the latter can be a means of emulation). This class should make\n    all of that easy.\n\n    SQL::ObjectModel is especially suited for use with applications or\n    modules that make use of data dictionaries to control what they do.\n    It is common in applications that they interpret their data\n    dictionaries and generate SQL to accomplish some of their work,\n    which means making sure generated SQL is in the right dialect or\n    syntax, and making sure literal values are escaped correctly. By\n    using this module, applications can simply copy appropriate\n    individual elements in their data dictionaries to SQL::ObjectModel\n    properties, including column names, table names, function names,\n    literal values, bind variable names, and they don't have to do any\n    string parsing or assembling.\n\n    Now, I can only imagine why all of the other SQL generating/parsing\n    modules that I know about have excluded privileged support for more\n    advanced database features like stored procedures. Either the\n    authors didn't have a need for it, or they figured that any other\n    prospective users wouldn't need it, or they found it too difficult\n    to implement so far and maybe planned to do it later. As for me, I\n    can see tremendous value in various advanced features, and so I have\n    included privileged support for them in SQL::ObjectModel. You simply\n    have to work on projects of a significant size to get an idea that\n    these features would provide a large speed, reliability, and\n    security savings for you. Look at many large corporate or government\n    systems, such as those which have hundreds of tables or millions of\n    records, and that may have complicated business logic which governs\n    whether data is consistent/valid or not. Within reasonable limits,\n    the more work you can get the database to do internally, the better.\n    I believe that if these features can also be represented in a\n    database-neutral format, such as what SQL::ObjectModel attempts to\n    do, then users can get the full power of a database without being\n    locked into a single vendor due to all their investment in\n    vendor-specific SQL stored procedure code. If customers can move a\n    lot more easily, it will help encourage database vendors to keep\n    improving their products or lower prices to keep their customers,\n    and users in general would benefit. So I do have reasons for trying\n    to tackle the advanced database features in SQL::ObjectModel."
   },
   "meta" : {
      "message_id" : "200307080436.h684auQp016452@pause.perl.org",
      "epoch" : 1057639016,
      "from" : "upload@pause.x.perl.org",
      "subject" : "Module submission SQL::ObjectModel",
      "file" : "22272.txt",
      "type" : "module_submission"
   }
}
