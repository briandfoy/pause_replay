{
   "data" : {
      "userid" : {
         "name" : "Darren Duncan",
         "id" : "DUNCAND"
      },
      "description" : "Framework for RDBMS-generic apps and schemas",
      "communities" : "victoria-pm@pm.org - more later when demo is up",
      "chapterid" : {
         "name" : "Database_Interfaces",
         "id" : "7"
      },
      "similar" : "more than fit here; eg: DBI, SQL::Schema, DBIx::AnyDBD,\n    SQL::Builder, DBIx::Browse, DBIx::Abstract, DBIx::SearchBuilder, ...",
      "DSLIP" : "cdpOp",
      "modid" : "DBIx::Portable",
      "enteredon" : "Mon Jan  6 06:56:48 2003 GMT",
      "enteredby" : {
         "name" : "Darren Duncan",
         "id" : "DUNCAND"
      },
      "PS" : "The following links are only valid for module list maintainers:",
      "rationale" : "I will make a detailed list how how each of the above and other\n    modules are different from or like mine in the near future.\n    Meanwhile, here is a general summary, from my module's Description\n    POD (hopefully not truncated by form): -----------------------------\n\n    DESCRIPTION\n\n    The DBIx::Portable framework is intended to support complex (or\n    simple) database-using applications that are easily portable across\n    databases because common product-specific details are abstracted\n    away. These include the RDBMS product and vendor name, what dialect\n    of SQL its scripting or query interface uses, whether the product\n    uses SQL at all or some other method of querying, how query results\n    are returned, what features the RDBMS supports, how to manage\n    connections, how to manage schema, how to manage stored procedures,\n    and perhaps how to manage users. The main thing that this framework\n    will not be doing in the forseeable future is managing the\n    installation and configuration of the RDBMS itself, which may be on\n    the same machine or a different one.\n\n    There are two main types of functionality that the DBIx::Portable\n    framework is designed to implement; this functionality may be better\n    described in different groupings.\n\n    The first functionality type is the management (creation,\n    modification, deletion) of the schema in a database, including:\n    tables, keys, constraints, relations, sequences, views, stored\n    procedures, triggers, and users. This type of functionality\n    typically is used infrequently and sets things up for the main\n    functionality of your database-using application(s). In some cases,\n    typically with single-user desktop applications, the application may\n    install its own schema, and/or create new database files, when it\n    starts up or upon the user's prompting; this can be analogous to the\n    result of a \"New...\" (or \"Save As...\") command in a desktop\n    financial management or file archiving application; the application\n    would then carry on to use the schema as its personal working space.\n    In other cases, typically with multiple-user client-server\n    applications, one \"Installer\" or \"Manager\" type application or\n    process with exclusive access will be run once to create the schema,\n    and then a separate application or process will be run to make use\n    of it as a shared working space.\n\n    The second functionality type is the management (creation,\n    modification, deletion) of the data in a database, including such\n    operations as: direct selects from single or multiple tables or\n    views, direct inserts or updates or deletes of records, calling\n    stored procedures, using sequences, managing temporary tables,\n    managing transactions, managing data integrity. This type of\n    functionality typically is used frequently and comprises the main\n    functionality of your database-using application(s). In some cases,\n    typically with public-accessible websites or services, all or most\n    users will just be viewing data and not changing anything; everyone\n    would use the same database user and they would not be prompted for\n    passwords or other security credentials. In other cases, typically\n    with private or restricted-access websites or services, all or most\n    users will also be changing data; everyone would have their own real\n    or application-simulated database user, whom they log in as with a\n    password or other credentials; as the application implements, these\n    users can have different activity privileges, and their actions can\n    be audited.\n\n    The DBIx::Portable framework can be considered a low-level service\n    because it allows a fine level of granularity or detail for the\n    commands you can make of it and the results you get back; you get a\n    detailed level of control. But it is not low-level in the way that\n    you would be entering any raw SQL, or even small fragments of raw\n    SQL; that is expressly avoided because it would expose\n    implementation details that aren't true on all databases. Rather,\n    this framework provides the means for you to specify in an\n    RDBMS-generic fashion exactly what it is you want to happen, and\n    your request is mapped to native or emulated functionality for the\n    actual RDBMS that is being used, to do the work. The implementation\n    or mapping is different for each RDBMS being abstracted away, and\n    makes maximum use of that database's built-in functionality.\n    Thereby, the DBIx::Portable framework achieves the greatest\n    performance possible while still being 100% RDBMS-generic.\n\n    This differs from other database abstraction modules or frameworks\n    that I am aware of on CPAN, since the others tend to either work\n    towards the lowest-common-denominator database while emulating more\n    complex functionality, which is very slow, or more often they\n    provide a much more limited number of abstracted functions and\n    expect you to do things manually (which is specific to single\n    databases or non-portable) with any other functionality you need.\n    With many modules, even the abstracted functions tend to accept sql\n    fragments as part of their input, which in the broadest sense makes\n    those non-portable as well. With my framework I am attempting the\n    \"holy grail\" of maximum portability with maximum features and\n    maximum speed, which to my knowledge none of the existing solutions\n    on CPAN are doing, or would be able to do short of a full rewrite.\n    This is largely why I am starting a new module framework rather than\n    trying to help patch an existing solution; I believe a rewrite is\n    needed."
   },
   "meta" : {
      "message_id" : "200301060656.h066unN24752@pause.perl.org",
      "epoch" : 1041836209,
      "from" : "upload@pause.x.perl.org",
      "subject" : "Module submission DBIx::Portable",
      "file" : "16688.txt",
      "type" : "module_submission"
   }
}
